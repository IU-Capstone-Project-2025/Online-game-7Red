/*
    Red7 Dataset Reader and Decoder

    Описание(ru):
    Этот файл реализует инструмент для чтения и декодирования строк из файла `dataset.txt`,
    созданного симуляцией Red7. Каждая строка представляет собой состояние игры в бинарном виде,
    включая активное правило, карты в руке, палитры, колоду и флаги "выбыл" и "победил".
    Скрипт преобразует бинарные маски обратно в человекочитаемый вид с указанием карт и состояния игрока.

    Основные компоненты:
    - enum Color: перечисление цветов (Red, Orange, Yellow, Green, Blue, Indigo, Violet).
    - getCardFromIndex: возвращает строковое представление карты по её индексу (0–49).
    - decodeBitmask: принимает строку из 50 бит и возвращает список карт, представленных в этой маске.
    - decodeLine: разбирает одну строку из файла dataset.txt и выводит расшифрованное состояние в консоль.
    - main: читает файл построчно и вызывает decodeLine для каждой строки.

        Формат входных данных (каждая строка):
        [0]  gameNumber         — номер симулированной игры
        [1]  roundNumber        — номер раунда
        [2]  playerNumber       — номер игрока (с 1)
        [3]  ruleCardBinary     — 50 бит, текущая карта-правило
        [4]  handBinary         — 50 бит, карты в руке игрока
        [5]  paletteBinary      — 50 бит, палитра игрока
        [6]  otherPalettesBinary — 50 бит, объединённая палитра других игроков
        [7]  deckBinary         — 50 бит, оставшиеся в колоде карты
        [8]  eliminatedFlag     — 0 = игрок активен, 1 = выбыл
        [9]  winFlag            — 0 = проиграл, 1 = победил

    Описание битовых полей:
    - Каждая маска — строка из 50 символов ('0' или '1').
    - Карты индексируются от 0 до 49:
        - Индекс = color * 7 + (value - 1)
        - Индекс 49 — специальная карта "Red 0", не входит в колоду, используется как начальное правило.
    - '1' означает, что карта с этим индексом присутствует в руке / палитре / колоде / правиле.
    - В ruleCardBinary должен быть установлен ровно один бит.

        Использование:
    - Вывод: декодированное состояние игры выводится в stdout (терминал/консоль)
*/

/*
    Red7 Dataset Reader and Decoder

    Description(eng):
    This file implements a utility for reading and decoding lines from `dataset.txt`,
    which was generated by a Red7 simulation. Each line represents a binary-encoded game state,
    including the current rule, player's hand, palettes, deck, and 'eliminated'/'won' flags.
    The tool converts these binary masks into human-readable format showing card names and state.

    Main components:
    - enum Color: enumeration of the Red7 colour categories.
    - getCardFromIndex: returns string representation of a card given its index (0–49).
    - decodeBitmask: converts a 50-bit binary string into a list of card names.
    - decodeLine: parses one line from dataset.txt and prints a readable version to console.
    - main: reads the dataset file line by line and decodes each line.

    Input format (each line):
    [0] gameNumber         — the simulation game number
    [1] roundNumber        — round number
    [2] playerNumber       — player number (starting from 1)
    [3] ruleCardBinary     — 50 bits, current rule card
    [4] handBinary         — 50 bits, player’s hand
    [5] paletteBinary      — 50 bits, player's palette
    [6] otherPalettesBinary — 50 bits, combined palettes of other players
    [7] deckBinary         — 50 bits, remaining cards in deck
    [8] eliminatedFlag     — 0 = active player, 1 = eliminated
    [9] winFlag            — 0 = lost, 1 = won

    Description of bit fields:
    - Each bitmask is a 50-character string ('0' or '1').
    - Cards are indexed 0 through 49:
        - Index = color * 7 + (value - 1)
        - Index 49 is the special "Red 0" card (not part of the deck)
    - A bit set to '1' means the corresponding card is present in hand/palette/deck/rule.
    - ruleCardBinary must contain exactly one bit set to 1.

    Usage:
    - Output: human-readable game state printed to stdout
*/

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <sstream>

enum Color {
    Red, Orange, Yellow, Green, Blue, Indigo, Violet
};

std::string getCardFromIndex(int index) {
    if (index < 0 || index >= 50) return "Invalid";
    if (index == 49) return "Red 0";  // индекс 49 — красная 0

    int color = index / 7;
    int value = (index % 7) + 1;
    const char* colors[] = { "Red", "Orange", "Yellow", "Green", "Blue", "Indigo", "Violet" };
    return std::string(colors[color]) + " " + std::to_string(value);
}

std::vector<std::string> decodeBitmask(const std::string& bitmask) {
    std::vector<std::string> cards;
    for (int i = 0; i < 50 && i < bitmask.size(); ++i) {
        if (bitmask[i] == '1') {
            cards.push_back(getCardFromIndex(i));
        }
    }
    return cards;
}

void decodeLine(const std::string& line) {
    std::stringstream ss(line);
    std::string token;
    std::vector<std::string> fields;

    while (std::getline(ss, token, ',')) {
        fields.push_back(token);
    }

    if (fields.size() != 10) {
        std::cerr << "Invalid input line format: " << line << std::endl;
        return;
    }

    int gameNumber = std::stoi(fields[0]);
    int roundNumber = std::stoi(fields[1]);
    int playerNumber = std::stoi(fields[2]);
    std::string ruleCardBinary = fields[3];
    std::string handBinary = fields[4];
    std::string paletteBinary = fields[5];
    std::string otherPaletteBinary = fields[6];
    std::string deckBinary = fields[7];
    bool eliminated = fields[8] == "1";
    bool won = fields[9] == "1";

    std::vector<std::string> ruleCards = decodeBitmask(ruleCardBinary);
    std::vector<std::string> handCards = decodeBitmask(handBinary);
    std::vector<std::string> paletteCards = decodeBitmask(paletteBinary);
    std::vector<std::string> otherPaletteCards = decodeBitmask(otherPaletteBinary);
    std::vector<std::string> deckCards = decodeBitmask(deckBinary);

    std::cout << "\nGame: " << gameNumber << ", Round: " << roundNumber
              << ", Player: " << playerNumber << "\n";

    std::cout << "Rule Card(s): ";
    for (const auto& card : ruleCards) std::cout << card << ", ";
    std::cout << "\nHand: ";
    for (const auto& card : handCards) std::cout << card << ", ";
    std::cout << "\nPalette: ";
    for (const auto& card : paletteCards) std::cout << card << ", ";
    std::cout << "\nOther Palettes: ";
    for (const auto& card : otherPaletteCards) std::cout << card << ", ";
    std::cout << "\nDeck: ";
    for (const auto& card : deckCards) std::cout << card << ", ";
    std::cout << "\nEliminated: " << (eliminated ? "Yes" : "No");
    std::cout << ", Won: " << (won ? "Yes" : "No") << "\n";
}

int main() {
    std::ifstream infile("dataset.txt");
    if (!infile) {
        std::cerr << "Failed to open dataset.txt" << std::endl;
        return 1;
    }

    std::string line;
    while (std::getline(infile, line)) {
        if (!line.empty()) {
            decodeLine(line);
        }
    }

    infile.close();
    return 0;
}
